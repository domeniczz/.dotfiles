#!/usr/bin/env bash

set -euo pipefail

# ------------------------------------------------------------------------------
# Search through the whole system with persistent index
# and perform actions (preview, open, delete)
# ------------------------------------------------------------------------------

export LC_ALL=C

declare -gr INCLUDED_DIRS=(
    "/home"
    "/etc"
    "/opt"
    "/usr"
    "/var"
)

declare -gr EXCLUDED_DIRS_FD=(
    "/proc"
    "/sys"
    ".git"
    ".venv"
    "node_modules"
    "__pycache__"
    "*/.cache/go/"
    "*/.cache/go-build/"
    "*/.local/share/Trash/"
)

declare -gr EXCLUDED_DIRS_FIND=(
    "/proc"
    "/sys"
    "*/\.git*"
    "*/\.venv*"
    "*/node_modules*"
    "*/__pycache__*"
    "*/\.cache/go*"
    "*/\.cache/go-build*"
    "*/\.local/share/Trash*"
)

declare -gr INDEX_DIR="${XDG_DATA_HOME:-$HOME/.local/share}/search"
declare -gr INDEX_FILE="$INDEX_DIR/index"
declare -gr PLAIN_INDEX_FILE="$INDEX_DIR/plain_index"
declare -gr TMP_DIR="$(mktemp -d "${TMPDIR:-/tmp}/search_XXXXXX")"
declare -gr LOCK_FILE="${TMPDIR:-/tmp}/search.lock"

declare -gr EXPLORER="${FILE_MANAGER:-vifm}"

declare -g ENABLE_COLORS=1

declare -g FIND_CMD=""

declare -g NEEDS_INDEX_REBUILD=0
declare -g FORCE_INDEX_REBUILD=0

declare -g SEARCH_QUERY=""

if command -v mawk >/dev/null 2>&1; then
    declare -gr AWK="mawk -W posix"
elif command -v gawk >/dev/null 2>&1; then
    declare -gr AWK="gawk --characters-as-bytes"
elif command -v awk >/dev/null 2>&1; then
    declare -gr AWK="awk"
else
    echo "AWK interpreter does not exists!" >&2
    exit 1
fi

if command -v rg >/dev/null 2>&1; then
    declare -gr GREP="rg --no-config --no-line-number"
elif command -v grep >/dev/null 2>&1; then
    declare -gr GREP="grep"
else
    echo "Grep does not exists!" >&2
    exit 1
fi

declare -gr SED="sed --posix"

# ------------------------------------------------------------------------------
# Parse arguments
# ------------------------------------------------------------------------------

function print_usage() {
    cat << 'EOF'
Usage: search [OPTIONS]

Search through the whole system with persistent index and perform actions
(preview, open, delete) using an interactive fuzzy finder interface.

OPTIONS:
    -s, --search     Search query
    -c, --color      Enable colored output (default)
    -nc, --nocolor   Disable colored output
    -r, --rebuild    Force rebuild of the search index
    -h, --help       Show this help message and exit

INTERACTIVE KEYS:
    Enter            Open selected item(s)
    Ctrl-o           Open parent directory of selected item
    Ctrl-x / F9      Delete selected item(s)
    Ctrl-Shift-r     Rebuild search index

EXAMPLES:
    search
    search --rebuild
    search --nocolor
EOF
}

while (( $# > 0 )); do
    case $1 in
        --)
            shift
            break
            ;;
        --color|-c)
            ENABLE_COLORS=1
            shift
            ;;
        --nocolor|-nc)
            ENABLE_COLORS=0
            shift
            ;;
        --rebuild|-r)
            FORCE_INDEX_REBUILD=1
            shift
            ;;
        --help|-h)
            print_usage
            exit 0
            shift
            ;;
        --search=*|-s=*)
            SEARCH_QUERY="${1#*=}"
            shift
            ;;
        --search|-s)
            shift
            if (( $# > 0 )); then
                SEARCH_QUERY="$1"
                shift
            else
                echo "Error: --search requires an argument" >&2
                exit 1
            fi
            ;;
        *)
            shift
            ;;
    esac
done

# ------------------------------------------------------------------------------
# Open item
# ------------------------------------------------------------------------------

function open_item() {
    local item="$(parse_item "$1")" || return 0
    local escaped_item=$(printf '%q' "$item")

    if [[ -d "$item" ]]; then
        tui_open "$EXPLORER $escaped_item"
        return 0
    fi

    local mime_type=$(file --brief --mime-type "$item" || echo "unknown")
    case "$mime_type" in
        text/*)
            tui_open "nvim $escaped_item"
            ;;
        application/json|application/xml|application/x-tex|application/toml|application/x-yaml)
            tui_open "nvim $escaped_item"
            ;;
        application/javascript|application/x-sh|application/x-shellscript)
            tui_open "nvim $escaped_item"
            ;;
        application/pdf|application/epub+zip)
            if has_gui; then
                gui_open "zathura $escaped_item"
            else
                tui_open "echo 'Loading file content...' && pdftotext $escaped_item - | less"
            fi
            ;;
        inode/x-empty|application/x-empty|application/x-zerosize)
            tui_open "nvim $escaped_item"
            ;;
        *)
            if has_gui; then
                gui_open "xdg-open $escaped_item"
            else
                echo "No gui support detected."
                read -r -p "Open in $EXPLORER? (y/n): " confirm
                if [[ "${confirm:-n}" =~ ^[Yy]$ ]]; then
                    open_parent_directory "$item"
                fi
            fi
            ;;
    esac
}

function open_parent_directory() {
    local item="$(parse_item "$1")" || return 0
    local escaped_item=$(printf '%q' "$item")

    if [[ -d "$item" ]]; then
        tui_open "$EXPLORER $escaped_item"
    else
        local parent_dir="${item%/*}"
        tui_open "$EXPLORER $(printf '%q' "${parent_dir:-/}")"
    fi
}

function parse_item() {
    local item="$1"

    if [[ ! -e "$item" && ! -L "$item" ]]; then
        echo "Error: File or directory no longer exists: $item" >&2
        read -r -p "Remove from index? (y/n): " confirm
        if [[ "${confirm:-n}" =~ ^[Yy]$ ]]; then
            remove_from_index "$item" >&2
            echo "Item removed from index." >&2
            read -r -p "Press Enter to continue..." >&2
        fi
        return 1
    fi

    if [[ -L "$item" ]]; then
        local target="$(readlink -f "$item")"
        if [[ ! -e "$target" ]]; then
            echo "Error: Symlink target does not exist: $item -> $target" >&2
            read -r -p "Remove broken symlink? (y/n): " confirm
            if [[ "${confirm:-n}" =~ ^[Yy]$ ]]; then
                delete_items "$item" >&2
                echo "Item removed." >&2
                read -r -p "Press Enter to continue..." >&2
            fi
            return 1
        fi
        echo "$target"
        return 0
    fi

    echo "$item"
    return 0
}

function gui_open() {
    local cmd="$1"

    if ! check_command_string "$cmd"; then
        read -r -p "Press Enter to continue..."
        return 0
    fi

    { LC_ALL="" sh -c "$cmd" >/dev/null 2>&1 & } || true
}

function tui_open() {
    local cmd="$1"

    if ! check_command_string "$cmd"; then
        read -r -p "Press Enter to continue..."
        return 0
    fi

    if [[ -n "${TMUX:-}" ]]; then
        read -r win_name _ <<< "$cmd"
        LC_ALL="" tmux new-window "$cmd"
    elif [[ -n "${STY:-}" ]]; then
        read -r win_name _ <<< "$cmd"
        LC_ALL="" screen -S "$STY" -X screen "$cmd"
    else
        LC_ALL="" sh -c "$cmd"
    fi
}

# ------------------------------------------------------------------------------
# Remove item
# ------------------------------------------------------------------------------

function delete_items() {
    (( $# == 0 )) && return 0

    echo "Do you want to delete the following $# item(s)?"
    printf "  - %s\n" "$@"

    local confirm
    read -r -p "Proceed with deletion? (y/n): " confirm

    if [[ "${confirm:-n}" =~ ^[Yy]$ ]]; then
        local to_remove=()
        local dirs_to_delete=()
        local files_to_delete=()

        for item in "$@"; do
            if [[ ! -e "$item" ]]; then
                echo "Warning: $item no longer exists, removing from index only."
                to_remove+=("$item")
            elif [[ -d "$item" && ! -L "$item" ]]; then
                dirs_to_delete+=("$item")
                to_remove+=("$item")
                local nested=$(find_nested_entries "$item")
                [[ -n "$nested" ]] && while IFS= read -r entry; do
                    to_remove+=("$entry")
                done <<< "$nested"
            else
                files_to_delete+=("$item")
                to_remove+=("$item")
            fi
        done

        echo "Removing files/directories..."
        (( ${#files_to_delete[@]} > 0 )) && rm -f "${files_to_delete[@]}"
        (( ${#dirs_to_delete[@]} > 0 )) && rm -rf "${dirs_to_delete[@]}"

        if (( ${#to_remove[@]} > 0 )); then
            local lines_before=$(wc -l < "$INDEX_FILE")
            echo "Updating index..."
            remove_from_index "${to_remove[@]}"
            local lines_after=$(wc -l < "$INDEX_FILE")
            if (( lines_before == lines_after )); then
                echo "Nothing to update in index."
            else
                echo "Index updated."
            fi
            echo "Deletion completed."
        fi

        read -r -p "Press Enter to continue..."
    else
        echo "Deletion cancelled."
    fi
}

function regex_escaping() {
    local str="$1"
    str="${str//\\/\\\\}"
    str="${str//./\\.}"
    str="${str//\*/\\*}"
    str="${str//\[/\\[}"
    str="${str//\]/\\]}"
    str="${str//^/\\^}"
    str="${str//\$/\\$}"
    echo "$str"
}

function find_nested_entries() {
    local dir="$1"
    [[ "$dir" != */ ]] && dir="${dir}/"

    local index=$(((ENABLE_COLORS == 0)) && echo "$INDEX_FILE" || echo "$PLAIN_INDEX_FILE")
    local escaped_dir=$(regex_escaping "$dir")
    $GREP --color=never "^$escaped_dir" "$index" || true
}

function remove_from_index() {
    (( $# == 0 )) && return 0

    local tmp_index_file="$TMP_DIR/index_filtered"
    local tmp_plain_index_file="$TMP_DIR/plain_index_filtered"
    local exclude_file="$TMP_DIR/exclude_list"

    printf "%s\n" "$@" > "$exclude_file"

    if (( ENABLE_COLORS == 0 )); then
        if (( $# < 5000 )); then
            $GREP --invert-match --fixed-strings --line-regexp --file "$exclude_file" "$INDEX_FILE" > "$tmp_index_file"
        else
            $AWK -v exclude_file="$exclude_file" '
            BEGIN {
                while ((getline line < exclude_file) > 0) {
                    exclude[line] = 1
                }
                close(exclude_file)
            }
            !($0 in exclude)
            ' "$INDEX_FILE" > "$tmp_index_file"
        fi

        mv "$tmp_index_file" "$INDEX_FILE"
    else
        $AWK -v exclude_file="$exclude_file" -v colored_file="$INDEX_FILE" '
        BEGIN {
            while ((getline line < exclude_file) > 0) {
                exclude[line] = 1
            }
            close(exclude_file)
        }
        {
            if ((getline colored < colored_file) > 0) {
                if (!($0 in exclude)) {
                    print $0 > "'$tmp_plain_index_file'"
                    print colored > "'$tmp_index_file'"
                }
            }
        }' "$PLAIN_INDEX_FILE"

        mv "$tmp_index_file" "$INDEX_FILE"
        mv "$tmp_plain_index_file" "$PLAIN_INDEX_FILE"
    fi
}

# ------------------------------------------------------------------------------
# Build index
# ------------------------------------------------------------------------------

function build_index() {
    echo "Building index..."
    mkdir -p "$INDEX_DIR"

    [[ -z "$FIND_CMD" ]] && construct_find_command

    if (( ENABLE_COLORS == 1 )); then
        eval "$FIND_CMD" | sort | tee "$INDEX_FILE" | \
        $AWK '
        BEGIN {
            ANSI_REGEX = "\033\\[[0-9;]*m"
        }
        {
            line = $0
            gsub(ANSI_REGEX, "", line)
            print line
        }
        ' > "$PLAIN_INDEX_FILE"
    else
        eval "$FIND_CMD" | sort > "$INDEX_FILE" || true
    fi

    local count=$(wc -l < "$INDEX_FILE")
    echo "Index built successfully with $count entries."
}

function check_index() {
    NEEDS_INDEX_REBUILD=0
    if (( FORCE_INDEX_REBUILD )); then
        NEEDS_INDEX_REBUILD=1
        return 0
    fi
    if (( ENABLE_COLORS != 0 )); then
        if [[ ! -f "$PLAIN_INDEX_FILE" ]] || [[ ! -f "$INDEX_FILE" ]]; then
            NEEDS_INDEX_REBUILD=1
            return 0
        fi
        if (( $(wc -l < "$INDEX_FILE") != $(wc -l < "$PLAIN_INDEX_FILE") )); then
            NEEDS_INDEX_REBUILD=1
            return 0
        fi
        if ! $GREP --quiet --color=never $'\033\\[[0-9;]*m' "$INDEX_FILE"; then
            NEEDS_INDEX_REBUILD=1
        fi
    else
        if [[ ! -f "$INDEX_FILE" ]]; then
            NEEDS_INDEX_REBUILD=1
            return 0
        fi
        if $GREP --quiet --color=never $'\033\\[[0-9;]*m' "$INDEX_FILE"; then
            NEEDS_INDEX_REBUILD=1
        fi
    fi
    return 0
}

# ------------------------------------------------------------------------------
# Utils
# ------------------------------------------------------------------------------

function construct_find_command() {
    local search_cmd=""

    if command -v fd >/dev/null 2>&1; then
        search_cmd="fd '' --hidden --no-ignore --absolute-path"
        if (( ENABLE_COLORS == 0 )); then
            search_cmd+=" --color=never"
        else
            search_cmd+=" --color=always"
        fi
        if (( ${#INCLUDED_DIRS[@]} > 0 )); then
            for dir in "${INCLUDED_DIRS[@]}"; do
                search_cmd+=" --search-path \"${dir}\""
            done
        else
            search_cmd+=" --search-path /"
        fi
        for dir in "${EXCLUDED_DIRS_FD[@]}"; do
            search_cmd+=" --exclude \"${dir}\""
        done
    else
        ENABLE_COLORS=0
        search_cmd="find -O2"
        if (( ${#INCLUDED_DIRS[@]} > 0 )); then
            for dir in "${INCLUDED_DIRS[@]}"; do
                search_cmd+=" \"${dir}\""
            done
        else
            search_cmd+=" /"
        fi
        for dir in "${EXCLUDED_DIRS_FIND[@]}"; do
            search_cmd+=" -path \"${dir}\" -prune -o"
        done
        search_cmd+=" -print"
    fi

    search_cmd+=" 2>/dev/null"
    FIND_CMD="$search_cmd"
}

function select_command() {
    local commands=("$@")

    for cmd in "${commands[@]}"; do
        if check_command_string "$cmd"; then
            printf '%s\n' "$cmd"
            return 0
        fi
    done

    printf '%s\n' "echo 'Cannot preview, command not exists'"
}

function construct_fzf_preview_command() {
    local dir_cmd=$(select_command \
        "eza -la --color=always {} 2>/dev/null" \
        "ls -la --color=always {} 2>/dev/null")

    local html_cmd=$(select_command \
        "w3m -dump -X -M -T text/html -no-mouse -no-graph -no-cookie {}" \
        "bat --color=always --style=plain --line-range=:200 {} 2>/dev/null" \
        "cat {} 2>/dev/null")

    local text_cmd=$(select_command \
        "bat --color=always --style=plain --line-range=:200 {} 2>/dev/null" \
        "cat {} 2>/dev/null")

    local general_archive_cmd=$(select_command \
        "bsdtar -tvf {} | awk '{print \$6 \" \" \$7 \" \" \$8 \" - \" \$NF}' 2>/dev/null" \
        "7z l -ba {} | awk '{print \$1 \" \" \$2 \" - \" \$NF}' 2>/dev/null")

    local gzip_archive_cmd=$(select_command \
        "7z l -ba {} | awk '{print \$1 \" \" \$2 \" - \" \$NF}'select_command 2>/dev/null" \
        "gzip -l {}")

    local pdf_cmd=$(select_command \
        "pdftotext -nopgbrk -l 3 {} - 2>/dev/null")

    local epub_cmd=$(select_command \
        "epub2txt {} - 2>/dev/null")

    local docx_cmd=$(select_command \
        "docx2txt {} - 2>/dev/null")

    local doc_cmd=$(select_command \
        "catdoc {} 2>/dev/null")

    local general_file_cmd=$(select_command \
        "file --brief {} 2>/dev/null")

    printf '%s' "
        function preview_file_content() {
            local file_path=\"\$1\"
            file_info=\$(stat --format='size: %s bytes, last modified: %y' \"\$file_path\" 2>/dev/null | cut -d. -f1)
            echo -e \"\$file_info\n\"
            local mime_type=\$(file --brief --mime-type \"\$file_path\" 2>/dev/null)
            case \"\$mime_type\" in
                text/html)
                    $html_cmd
                    ;;
                text/*|application/json|application/xml|application/javascript|application/x-sh|application/x-shellscript|application/x-tex|application/toml|application/x-yaml)
                    $text_cmd
                    ;;
                application/zip|application/java-archive|application/x-rar|application/x-7z-compressed|application/x-tar|application/x-gzip|application/x-bzip2|application/x-xz|application/zstd)
                    $general_archive_cmd
                    ;;
                application/gzip)
                    $gzip_archive_cmd
                    ;;
                application/pdf)
                    $pdf_cmd
                    ;;
                application/epub+zip)
                    $epub_cmd
                    ;;
                application/vnd.openxmlformats-officedocument.*)
                    $docx_cmd
                    ;;
                application/msword)
                    $doc_cmd
                    ;;
                inode/x-empty|application/x-empty|application/x-zerosize)
                    echo 'empty file'
                    ;;
                *)
                    $general_file_cmd
                    ;;
            esac
        }

        if [[ -L {} ]]; then
            target=\$(readlink -f {} 2>/dev/null)
            if [[ -n \$target ]]; then
                echo \"symbolic link to \$target\n\"
                if [[ -d \$target ]]; then
                    dir_info=\$(stat --format='last modified: %y' \$target 2>/dev/null | cut -d. -f1)
                    echo -e \"\$dir_info\n\"
                    $dir_cmd
                elif [[ -e \$target ]]; then
                    preview_file_content \$target
                else
                    echo 'link target does not exist'
                fi
            else
                echo 'broken symbolic link'
            fi
        elif [[ -d {} ]]; then
            dir_info=\$(stat --format='last modified: %y' {} 2>/dev/null | cut -d. -f1)
            echo -e \"\$dir_info\n\"
            $dir_cmd
        else
            preview_file_content {}
        fi
    "
}

function check_command_string() {
    local cmd_string="$1"

    cmd_string="${cmd_string//&&/|}"
    cmd_string="${cmd_string//||/|}"

    if [[ "$cmd_string" != *'"'* && "$cmd_string" != *"'"* ]]; then
        IFS='|' read -ra pipeline_parts <<< "$cmd_string"
        for part in "${pipeline_parts[@]}"; do
            read -r cmd_name _ <<< "$part"
            if ! command -v "$cmd_name" >/dev/null 2>&1; then
                echo "$cmd_name does not exists." >&2
                return 1
            fi
        done
        return 0
    fi

    local commands=()
    local current_cmd=""
    local in_single_quote=0
    local in_double_quote=0
    local escaped=0

    for ((i = 0; i < ${#cmd_string}; i++)); do
        local char="${cmd_string:$i:1}"

        if (( escaped )); then
            current_cmd+="$char"
            escaped=0
            continue
        fi

       case "$char" in
            "\\")
                if (( !in_single_quote )); then
                    escaped=1
                fi
                current_cmd+="$char"
                ;;
            "'")
                if (( !in_double_quote )); then
                    (( in_single_quote = !in_single_quote ))
                fi
                current_cmd+="$char"
                ;;
            '"')
                if (( !in_single_quote )); then
                    (( in_double_quote = !in_double_quote ))
                fi
                current_cmd+="$char"
                ;;
            "|")
                if (( !in_single_quote && !in_double_quote )); then
                    [[ -n "${current_cmd// }" ]] && commands+=("$current_cmd")
                    current_cmd=""
                else
                    current_cmd+="$char"
                fi
                ;;
            *)
                current_cmd+="$char"
                ;;
        esac
    done

    [[ -n "${current_cmd// }" ]] && commands+=("$current_cmd")

    for part in "${commands[@]}"; do
        read -r cmd_name _ <<< "$part"
        if ! command -v "$cmd_name" >/dev/null 2>&1; then
            echo "$cmd_name does not exists." >&2
            return 1
        fi
    done

    return 0
}

function has_gui() {
    [[ -n "${WAYLAND_DISPLAY:-}" ]] || \
    [[ -n "${DISPLAY:-}" ]] || \
    [[ "${XDG_SESSION_TYPE:-}" == "wayland" ]] || \
    [[ "${XDG_SESSION_TYPE:-}" == "x11" ]]
}

function ensure_single_instance() {
    exec 200>"$LOCK_FILE"
    if ! flock -n 200; then
        echo "Another instance of the script is already running." >&2
        read -r -p "Press Enter to continue..."
        exit 1
    fi
}

# ------------------------------------------------------------------------------
# Traps
# ------------------------------------------------------------------------------

function cleanup() {
    [[ -d "$TMP_DIR" ]] && rm -rf "$TMP_DIR" || true

    if command -v fd >/dev/null 2>&1; then
        fd --type d '^search_' "${TMPDIR:-/tmp}" --max-depth 1 --changed-before 30min --exec rm -rf '{}' ';' 2>/dev/null || true
    else
        find "${TMPDIR:-/tmp}" -maxdepth 1 -type d -name "search_*" -mmin +30 -exec rm -rf '{}' \; 2>/dev/null || true
    fi
}

trap cleanup EXIT INT TERM QUIT PIPE

# ------------------------------------------------------------------------------
# Main function
# ------------------------------------------------------------------------------

function main() {
    ensure_single_instance

    local preview_cmd="$(construct_fzf_preview_command)"

    check_index
    (( NEEDS_INDEX_REBUILD )) && build_index

    local query_string="$SEARCH_QUERY"

    while true; do
        local fzf_output=$(cat "$INDEX_FILE" | \
            fzf --ansi --no-cycle --border=none --multi --algo=v2 \
                --query="$query_string" --print-query \
                --preview="$preview_cmd" --preview-window '50%' \
                --expect=ctrl-x,ctrl-r,ctrl-o,enter,f1,f9 \
                --footer='Enter: open, Ctrl-o: open parent, Ctrl-x / F9: delete, Ctrl-r: rebuild index, F1: help' \
                --bind 'focus:transform-header:stat --printf="%A %U:%G" {}' \
            || echo "")

        [[ -z "$fzf_output" ]] && return 0

        query_string="${fzf_output%%$'\n'*}"
        fzf_output="${fzf_output#*$'\n'}"
        local key_pressed="${fzf_output%%$'\n'*}"
        if [[ "$fzf_output" == *$'\n'* ]]; then
            local items_selected="${fzf_output#*$'\n'}"
        else
            local items_selected=""
        fi

        local item_array=()
        [[ -n "$items_selected" ]] && while IFS= read -r line; do
            [[ -n "$line" ]] && item_array+=("$line")
        done <<< "$items_selected"

        if (( ${#item_array[@]} == 0 )); then
            echo "Nothing selected. No action taken."
            read -r -p "Press Enter to continue..."
            continue
        fi

        case "$key_pressed" in
            ctrl-r)
                build_index
                ;;
            ctrl-x|f9)
                delete_items "${item_array[@]}"
                ;;
            ctrl-o)
                if (( ${#item_array[@]} == 1 )); then
                    open_parent_directory "${item_array[0]}"
                else
                    echo "Multiple items selected. No action taken."
                    read -r -p "Press Enter to continue..."
                fi
                ;;
            enter)
                if (( ${#item_array[@]} == 1 )); then
                    open_item "${item_array[0]}"
                else
                    echo "Multiple items selected. No action taken."
                    read -r -p "Press Enter to continue..."
                fi
                ;;
            f1)
                print_usage
                echo ""
                read -r -p "Press Enter to continue..."
                ;;
        esac

        echo ""
    done
}

main
